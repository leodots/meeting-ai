import { NextRequest, NextResponse } from "next/server";
import { auth } from "../../../../../../auth";
import { prisma } from "@/lib/db/prisma";

interface Speaker {
  speakerIndex: number;
  label: string | null;
}

interface Utterance {
  text: string;
  startTime: number;
  speaker: Speaker;
}

interface Topic {
  title: string;
  description: string;
  importance: number;
}

interface KeyPoint {
  point: string;
  context?: string;
}

interface ActionItem {
  item: string;
  assignee?: string;
  priority?: string;
}

function formatTimestamp(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return `${hours}h ${mins}m ${secs}s`;
  }
  return `${mins}m ${secs}s`;
}

function getSpeakerName(speaker: Speaker): string {
  return speaker.label || `Speaker ${speaker.speakerIndex + 1}`;
}

function generateMarkdown(meeting: {
  title: string;
  description: string | null;
  duration: number | null;
  uploadedAt: Date;
  processedAt: Date | null;
  speakers: Speaker[];
  transcript: {
    utterances: Utterance[];
  } | null;
  analysis: {
    summary: string;
    topics: Topic[];
    keyPoints: KeyPoint[];
    actionItems: ActionItem[];
  } | null;
}): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${meeting.title}`);
  lines.push("");

  if (meeting.description) {
    lines.push(`> ${meeting.description}`);
    lines.push("");
  }

  // Metadata
  lines.push("## Meeting Info");
  lines.push("");
  lines.push(`- **Date:** ${meeting.uploadedAt.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" })}`);
  if (meeting.duration) {
    lines.push(`- **Duration:** ${formatDuration(meeting.duration)}`);
  }
  if (meeting.speakers.length > 0) {
    lines.push(`- **Participants:** ${meeting.speakers.map(getSpeakerName).join(", ")}`);
  }
  lines.push("");

  // Analysis
  if (meeting.analysis) {
    // Summary
    lines.push("## Summary");
    lines.push("");
    lines.push(meeting.analysis.summary);
    lines.push("");

    // Topics
    if (meeting.analysis.topics.length > 0) {
      lines.push("## Topics Discussed");
      lines.push("");
      for (const topic of meeting.analysis.topics) {
        const importance = "‚òÖ".repeat(topic.importance) + "‚òÜ".repeat(5 - topic.importance);
        lines.push(`### ${topic.title}`);
        lines.push("");
        lines.push(`*Importance: ${importance}*`);
        lines.push("");
        lines.push(topic.description);
        lines.push("");
      }
    }

    // Key Points
    if (meeting.analysis.keyPoints.length > 0) {
      lines.push("## Key Points");
      lines.push("");
      for (const point of meeting.analysis.keyPoints) {
        lines.push(`- **${point.point}**`);
        if (point.context) {
          lines.push(`  - ${point.context}`);
        }
      }
      lines.push("");
    }

    // Action Items
    if (meeting.analysis.actionItems.length > 0) {
      lines.push("## Action Items");
      lines.push("");
      for (const item of meeting.analysis.actionItems) {
        const priority = item.priority === "high" ? "üî¥" : item.priority === "low" ? "üü¢" : "üü°";
        const assignee = item.assignee ? ` (${item.assignee})` : "";
        lines.push(`- [ ] ${priority} ${item.item}${assignee}`);
      }
      lines.push("");
    }
  }

  // Transcript
  if (meeting.transcript && meeting.transcript.utterances.length > 0) {
    lines.push("## Full Transcript");
    lines.push("");

    for (const utterance of meeting.transcript.utterances) {
      const speaker = getSpeakerName(utterance.speaker);
      const timestamp = formatTimestamp(utterance.startTime);
      lines.push(`**[${timestamp}] ${speaker}:**`);
      lines.push(utterance.text);
      lines.push("");
    }
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(`*Generated by Meeting AI on ${new Date().toLocaleDateString()}*`);

  return lines.join("\n");
}

// GET /api/meetings/[id]/export?format=md|pdf
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const { searchParams } = new URL(request.url);
    const format = searchParams.get("format") || "md";

    const meeting = await prisma.meeting.findUnique({
      where: { id },
      include: {
        transcript: {
          include: {
            utterances: {
              include: {
                speaker: true,
              },
              orderBy: { orderIndex: "asc" },
            },
          },
        },
        analysis: true,
        speakers: {
          orderBy: { speakerIndex: "asc" },
        },
      },
    });

    if (!meeting) {
      return NextResponse.json({ error: "Meeting not found" }, { status: 404 });
    }

    if (meeting.userId !== session.user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    if (meeting.status !== "COMPLETED") {
      return NextResponse.json(
        { error: "Meeting must be processed before export" },
        { status: 400 }
      );
    }

    // Parse JSON fields
    const analysisData = meeting.analysis
      ? {
          summary: meeting.analysis.summary,
          topics: meeting.analysis.topics as Topic[],
          keyPoints: meeting.analysis.keyPoints as KeyPoint[],
          actionItems: meeting.analysis.actionItems as ActionItem[],
        }
      : null;

    const transcriptData = meeting.transcript
      ? {
          utterances: meeting.transcript.utterances.map((u) => ({
            text: u.text,
            startTime: u.startTime,
            speaker: {
              speakerIndex: u.speaker.speakerIndex,
              label: u.speaker.label,
            },
          })),
        }
      : null;

    const markdown = generateMarkdown({
      title: meeting.title,
      description: meeting.description,
      duration: meeting.duration,
      uploadedAt: meeting.uploadedAt,
      processedAt: meeting.processedAt,
      speakers: meeting.speakers.map((s) => ({
        speakerIndex: s.speakerIndex,
        label: s.label,
      })),
      transcript: transcriptData,
      analysis: analysisData,
    });

    if (format === "md") {
      const filename = `${meeting.title.replace(/[^a-z0-9]/gi, "_")}.md`;
      return new NextResponse(markdown, {
        headers: {
          "Content-Type": "text/markdown; charset=utf-8",
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      });
    }

    // For PDF, return HTML that can be printed/converted
    if (format === "html") {
      const html = generateHTML(meeting.title, markdown);
      const filename = `${meeting.title.replace(/[^a-z0-9]/gi, "_")}.html`;
      return new NextResponse(html, {
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      });
    }

    return NextResponse.json({ error: "Invalid format" }, { status: 400 });
  } catch (error) {
    console.error("Export error:", error);
    return NextResponse.json(
      { error: "Failed to export meeting" },
      { status: 500 }
    );
  }
}

function generateHTML(title: string, markdown: string): string {
  // Simple markdown to HTML conversion
  let html = markdown
    // Headers
    .replace(/^### (.*$)/gm, "<h3>$1</h3>")
    .replace(/^## (.*$)/gm, "<h2>$1</h2>")
    .replace(/^# (.*$)/gm, "<h1>$1</h1>")
    // Bold
    .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
    // Italic
    .replace(/\*(.*?)\*/g, "<em>$1</em>")
    // Blockquotes
    .replace(/^> (.*$)/gm, "<blockquote>$1</blockquote>")
    // Unordered lists
    .replace(/^- \[ \] (.*$)/gm, '<li class="todo">‚òê $1</li>')
    .replace(/^- (.*$)/gm, "<li>$1</li>")
    // Horizontal rule
    .replace(/^---$/gm, "<hr>")
    // Line breaks
    .replace(/\n\n/g, "</p><p>")
    .replace(/\n/g, "<br>");

  // Wrap lists
  html = html.replace(/(<li.*?<\/li>)+/g, "<ul>$&</ul>");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      color: #1a1a1a;
    }
    h1 {
      border-bottom: 2px solid #e5e5e5;
      padding-bottom: 0.5rem;
    }
    h2 {
      margin-top: 2rem;
      color: #333;
    }
    h3 {
      color: #555;
    }
    blockquote {
      border-left: 4px solid #e5e5e5;
      margin: 1rem 0;
      padding: 0.5rem 1rem;
      color: #666;
      background: #f9f9f9;
    }
    ul {
      padding-left: 1.5rem;
    }
    li {
      margin: 0.5rem 0;
    }
    li.todo {
      list-style: none;
      margin-left: -1.5rem;
    }
    hr {
      border: none;
      border-top: 1px solid #e5e5e5;
      margin: 2rem 0;
    }
    @media print {
      body {
        max-width: none;
        padding: 0;
      }
    }
  </style>
</head>
<body>
  <p>${html}</p>
</body>
</html>`;
}
