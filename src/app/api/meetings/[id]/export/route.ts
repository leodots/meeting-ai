import { NextRequest, NextResponse } from "next/server";
import { auth } from "../../../../../../auth";
import { prisma } from "@/lib/db/prisma";
import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import { log } from "@/lib/logger";

interface Speaker {
  speakerIndex: number;
  label: string | null;
}

interface Utterance {
  text: string;
  startTime: number;
  speaker: Speaker;
}

interface Topic {
  title: string;
  description: string;
  importance: number;
}

interface KeyPoint {
  point: string;
  context?: string;
}

interface ActionItem {
  item: string;
  assignee?: string;
  priority?: string;
}

function formatTimestamp(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return `${hours}h ${mins}m ${secs}s`;
  }
  return `${mins}m ${secs}s`;
}

function getSpeakerName(speaker: Speaker): string {
  return speaker.label || `Speaker ${speaker.speakerIndex + 1}`;
}

function generateMarkdown(meeting: {
  title: string;
  description: string | null;
  duration: number | null;
  uploadedAt: Date;
  processedAt: Date | null;
  speakers: Speaker[];
  transcript: {
    utterances: Utterance[];
  } | null;
  analysis: {
    summary: string;
    topics: Topic[];
    keyPoints: KeyPoint[];
    actionItems: ActionItem[];
    meetingDocument?: string | null;
  } | null;
}): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${meeting.title}`);
  lines.push("");

  if (meeting.description) {
    lines.push(`> ${meeting.description}`);
    lines.push("");
  }

  // Metadata
  lines.push("## Meeting Info");
  lines.push("");
  lines.push(`- **Date:** ${meeting.uploadedAt.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" })}`);
  if (meeting.duration) {
    lines.push(`- **Duration:** ${formatDuration(meeting.duration)}`);
  }
  if (meeting.speakers.length > 0) {
    lines.push(`- **Participants:** ${meeting.speakers.map(getSpeakerName).join(", ")}`);
  }
  lines.push("");

  // Analysis
  if (meeting.analysis) {
    // Summary
    lines.push("## Summary");
    lines.push("");
    lines.push(meeting.analysis.summary);
    lines.push("");

    // Topics
    if (meeting.analysis.topics.length > 0) {
      lines.push("## Topics Discussed");
      lines.push("");
      for (const topic of meeting.analysis.topics) {
        const importance = "‚òÖ".repeat(topic.importance) + "‚òÜ".repeat(5 - topic.importance);
        lines.push(`### ${topic.title}`);
        lines.push("");
        lines.push(`*Importance: ${importance}*`);
        lines.push("");
        lines.push(topic.description);
        lines.push("");
      }
    }

    // Key Points
    if (meeting.analysis.keyPoints.length > 0) {
      lines.push("## Key Points");
      lines.push("");
      for (const point of meeting.analysis.keyPoints) {
        lines.push(`- **${point.point}**`);
        if (point.context) {
          lines.push(`  - ${point.context}`);
        }
      }
      lines.push("");
    }

    // Action Items
    if (meeting.analysis.actionItems.length > 0) {
      lines.push("## Action Items");
      lines.push("");
      for (const item of meeting.analysis.actionItems) {
        const priority = item.priority === "high" ? "üî¥" : item.priority === "low" ? "üü¢" : "üü°";
        const assignee = item.assignee ? ` (${item.assignee})` : "";
        lines.push(`- [ ] ${priority} ${item.item}${assignee}`);
      }
      lines.push("");
    }

    // Meeting Document
    if (meeting.analysis.meetingDocument) {
      lines.push("## Meeting Document");
      lines.push("");
      lines.push(meeting.analysis.meetingDocument);
      lines.push("");
    }
  }

  // Transcript
  if (meeting.transcript && meeting.transcript.utterances.length > 0) {
    lines.push("## Full Transcript");
    lines.push("");

    for (const utterance of meeting.transcript.utterances) {
      const speaker = getSpeakerName(utterance.speaker);
      const timestamp = formatTimestamp(utterance.startTime);
      lines.push(`**[${timestamp}] ${speaker}:**`);
      lines.push(utterance.text);
      lines.push("");
    }
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(`*Generated by Meeting AI on ${new Date().toLocaleDateString()}*`);

  return lines.join("\n");
}

// GET /api/meetings/[id]/export?format=md|pdf
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;

  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const format = searchParams.get("format") || "md";

    const meeting = await prisma.meeting.findUnique({
      where: { id },
      include: {
        transcript: {
          include: {
            utterances: {
              include: {
                speaker: true,
              },
              orderBy: { orderIndex: "asc" },
            },
          },
        },
        analysis: true,
        speakers: {
          orderBy: { speakerIndex: "asc" },
        },
      },
    });

    if (!meeting) {
      return NextResponse.json({ error: "Meeting not found" }, { status: 404 });
    }

    if (meeting.userId !== session.user.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    if (meeting.status !== "COMPLETED") {
      return NextResponse.json(
        { error: "Meeting must be processed before export" },
        { status: 400 }
      );
    }

    // Parse JSON fields
    const analysisData = meeting.analysis
      ? {
          summary: meeting.analysis.summary,
          topics: meeting.analysis.topics as unknown as Topic[],
          keyPoints: meeting.analysis.keyPoints as unknown as KeyPoint[],
          actionItems: meeting.analysis.actionItems as unknown as ActionItem[],
          meetingDocument: meeting.analysis.meetingDocument,
        }
      : null;

    const transcriptData = meeting.transcript
      ? {
          utterances: meeting.transcript.utterances.map((u) => ({
            text: u.text,
            startTime: u.startTime,
            speaker: {
              speakerIndex: u.speaker.speakerIndex,
              label: u.speaker.label,
            },
          })),
        }
      : null;

    const markdown = generateMarkdown({
      title: meeting.title,
      description: meeting.description,
      duration: meeting.duration,
      uploadedAt: meeting.uploadedAt,
      processedAt: meeting.processedAt,
      speakers: meeting.speakers.map((s) => ({
        speakerIndex: s.speakerIndex,
        label: s.label,
      })),
      transcript: transcriptData,
      analysis: analysisData,
    });

    if (format === "md") {
      log.exportGenerated(id, "markdown");
      const filename = `${meeting.title.replace(/[^a-z0-9]/gi, "_")}.md`;
      return new NextResponse(markdown, {
        headers: {
          "Content-Type": "text/markdown; charset=utf-8",
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      });
    }

    if (format === "html") {
      log.exportGenerated(id, "html");
      const html = generateHTML(meeting.title, markdown);
      const filename = `${meeting.title.replace(/[^a-z0-9]/gi, "_")}.html`;
      return new NextResponse(html, {
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      });
    }

    if (format === "pdf") {
      const pdfBuffer = await generatePDF({
        title: meeting.title,
        description: meeting.description,
        duration: meeting.duration,
        uploadedAt: meeting.uploadedAt,
        processedAt: meeting.processedAt,
        speakers: meeting.speakers.map((s) => ({
          speakerIndex: s.speakerIndex,
          label: s.label,
        })),
        transcript: transcriptData,
        analysis: analysisData,
      });

      log.exportGenerated(id, "pdf");
      const filename = `${meeting.title.replace(/[^a-z0-9]/gi, "_")}.pdf`;
      return new NextResponse(Buffer.from(pdfBuffer), {
        headers: {
          "Content-Type": "application/pdf",
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      });
    }

    return NextResponse.json({ error: "Invalid format. Use: md, html, or pdf" }, { status: 400 });
  } catch (error) {
    log.error("Export failed", error, { meetingId: id });
    return NextResponse.json(
      { error: "Failed to export meeting" },
      { status: 500 }
    );
  }
}

async function generatePDF(meeting: {
  title: string;
  description: string | null;
  duration: number | null;
  uploadedAt: Date;
  processedAt: Date | null;
  speakers: Speaker[];
  transcript: {
    utterances: Utterance[];
  } | null;
  analysis: {
    summary: string;
    topics: Topic[];
    keyPoints: KeyPoint[];
    actionItems: ActionItem[];
    meetingDocument?: string | null;
  } | null;
}): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const pageWidth = 595.28; // A4
  const pageHeight = 841.89;
  const margin = 50;
  const contentWidth = pageWidth - margin * 2;

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let y = pageHeight - margin;

  const colors = {
    primary: rgb(0.09, 0.09, 0.11),
    secondary: rgb(0.44, 0.44, 0.48),
    accent: rgb(0.23, 0.51, 0.96),
  };

  // Helper to add new page if needed
  const checkNewPage = (needed: number) => {
    if (y - needed < margin) {
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      y = pageHeight - margin;
    }
  };

  // Helper to draw wrapped text
  const drawText = (text: string, font: typeof helvetica, size: number, color: typeof colors.primary, maxWidth: number = contentWidth) => {
    const words = text.split(" ");
    let line = "";
    const lineHeight = size * 1.4;

    for (const word of words) {
      const testLine = line + (line ? " " : "") + word;
      const testWidth = font.widthOfTextAtSize(testLine, size);

      if (testWidth > maxWidth && line) {
        checkNewPage(lineHeight);
        page.drawText(line, { x: margin, y, size, font, color });
        y -= lineHeight;
        line = word;
      } else {
        line = testLine;
      }
    }

    if (line) {
      checkNewPage(lineHeight);
      page.drawText(line, { x: margin, y, size, font, color });
      y -= lineHeight;
    }
  };

  // Title
  drawText(meeting.title, helveticaBold, 22, colors.primary);
  y -= 5;

  // Description
  if (meeting.description) {
    drawText(meeting.description, helvetica, 11, colors.secondary);
  }
  y -= 15;

  // Meeting Info
  drawText("Meeting Info", helveticaBold, 14, colors.primary);
  y -= 5;

  const dateStr = meeting.uploadedAt.toLocaleDateString("en-US", {
    weekday: "long", year: "numeric", month: "long", day: "numeric"
  });
  drawText(`Date: ${dateStr}`, helvetica, 10, colors.secondary);

  if (meeting.duration) {
    drawText(`Duration: ${formatDuration(meeting.duration)}`, helvetica, 10, colors.secondary);
  }

  if (meeting.speakers.length > 0) {
    drawText(`Participants: ${meeting.speakers.map(getSpeakerName).join(", ")}`, helvetica, 10, colors.secondary);
  }

  // Analysis
  if (meeting.analysis) {
    y -= 20;
    drawText("Summary", helveticaBold, 14, colors.primary);
    y -= 5;
    drawText(meeting.analysis.summary, helvetica, 10, colors.secondary);

    // Topics
    if (meeting.analysis.topics.length > 0) {
      y -= 20;
      drawText("Topics Discussed", helveticaBold, 14, colors.primary);
      y -= 5;
      for (const topic of meeting.analysis.topics) {
        const stars = "[" + "*".repeat(topic.importance) + "-".repeat(5 - topic.importance) + "]";
        drawText(`- ${topic.title} ${stars}`, helveticaBold, 10, colors.primary);
        drawText(`  ${topic.description}`, helvetica, 9, colors.secondary);
        y -= 5;
      }
    }

    // Key Points
    if (meeting.analysis.keyPoints.length > 0) {
      y -= 15;
      drawText("Key Points", helveticaBold, 14, colors.primary);
      y -= 5;
      for (const point of meeting.analysis.keyPoints) {
        drawText(`- ${point.point}`, helveticaBold, 10, colors.primary);
        if (point.context) {
          drawText(`  ${point.context}`, helvetica, 9, colors.secondary);
        }
        y -= 3;
      }
    }

    // Action Items
    if (meeting.analysis.actionItems.length > 0) {
      y -= 15;
      drawText("Action Items", helveticaBold, 14, colors.primary);
      y -= 5;
      for (const item of meeting.analysis.actionItems) {
        const priority = item.priority ? `[${item.priority.toUpperCase()}]` : "";
        const assignee = item.assignee ? ` (${item.assignee})` : "";
        drawText(`[ ] ${priority} ${item.item}${assignee}`, helvetica, 10, colors.primary);
        y -= 3;
      }
    }

    // Meeting Document
    if (meeting.analysis.meetingDocument) {
      y -= 20;
      drawText("Meeting Document", helveticaBold, 14, colors.primary);
      y -= 5;
      drawText(meeting.analysis.meetingDocument, helvetica, 10, colors.secondary);
    }
  }

  // Transcript on new page
  if (meeting.transcript && meeting.transcript.utterances.length > 0) {
    page = pdfDoc.addPage([pageWidth, pageHeight]);
    y = pageHeight - margin;

    drawText("Full Transcript", helveticaBold, 14, colors.primary);
    y -= 10;

    for (const utterance of meeting.transcript.utterances) {
      const speaker = getSpeakerName(utterance.speaker);
      const timestamp = formatTimestamp(utterance.startTime);

      checkNewPage(40);
      drawText(`[${timestamp}] ${speaker}:`, helveticaBold, 9, colors.accent);
      drawText(utterance.text, helvetica, 10, colors.secondary);
      y -= 8;
    }
  }

  // Footer on last page
  y = margin;
  page.drawText(`Generated by Meeting AI on ${new Date().toLocaleDateString()}`, {
    x: margin,
    y,
    size: 8,
    font: helvetica,
    color: colors.secondary,
  });

  return await pdfDoc.save();
}

function generateHTML(title: string, markdown: string): string {
  // Simple markdown to HTML conversion
  let html = markdown
    // Headers
    .replace(/^### (.*$)/gm, "<h3>$1</h3>")
    .replace(/^## (.*$)/gm, "<h2>$1</h2>")
    .replace(/^# (.*$)/gm, "<h1>$1</h1>")
    // Bold
    .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
    // Italic
    .replace(/\*(.*?)\*/g, "<em>$1</em>")
    // Blockquotes
    .replace(/^> (.*$)/gm, "<blockquote>$1</blockquote>")
    // Unordered lists
    .replace(/^- \[ \] (.*$)/gm, '<li class="todo">‚òê $1</li>')
    .replace(/^- (.*$)/gm, "<li>$1</li>")
    // Horizontal rule
    .replace(/^---$/gm, "<hr>")
    // Line breaks
    .replace(/\n\n/g, "</p><p>")
    .replace(/\n/g, "<br>");

  // Wrap lists
  html = html.replace(/(<li.*?<\/li>)+/g, "<ul>$&</ul>");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      color: #1a1a1a;
    }
    h1 {
      border-bottom: 2px solid #e5e5e5;
      padding-bottom: 0.5rem;
    }
    h2 {
      margin-top: 2rem;
      color: #333;
    }
    h3 {
      color: #555;
    }
    blockquote {
      border-left: 4px solid #e5e5e5;
      margin: 1rem 0;
      padding: 0.5rem 1rem;
      color: #666;
      background: #f9f9f9;
    }
    ul {
      padding-left: 1.5rem;
    }
    li {
      margin: 0.5rem 0;
    }
    li.todo {
      list-style: none;
      margin-left: -1.5rem;
    }
    hr {
      border: none;
      border-top: 1px solid #e5e5e5;
      margin: 2rem 0;
    }
    @media print {
      body {
        max-width: none;
        padding: 0;
      }
    }
  </style>
</head>
<body>
  <p>${html}</p>
</body>
</html>`;
}
